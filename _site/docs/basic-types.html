<!DOCTYPE html>
    <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">


<link rel="Shortcut Icon" href="/kotlin-web-site/assets/images/favicon.ico" type="image/x-icon"/>
<link rel="apple-touch-icon" href="/kotlin-web-site/assets/images/apple-touch-icon.png" />
<link rel="apple-touch-icon" sizes="72x72" href="/kotlin-web-site/assets/images/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon" sizes="114x114" href="/kotlin-web-site/assets/images/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon" sizes="144x144" href="/kotlin-web-site/assets/images/apple-touch-icon-144x144.png" />
<link rel="stylesheet" href="/kotlin-web-site/css/styles.css">
<link rel="stylesheet" href="/kotlin-web-site/css/syntax.css">
<link rel="stylesheet" href="/kotlin-web-site/css/keywords.css">


<title>Basic Types</title>

    </head>
    <body>
    <section>
        <div class="container">
            <div class="grid">
                <div class="row">
                    <div class="col-2">
                        <h1>Basic Types</h1>
                        <!--<ul class="navigation">
                            <li><a href="">Docs Home</a></li>
                            <li><a href="">Examples</a></li>
                            <li><a href="">Comparison to Java</a></li>
                            <li><a href="">Comparison to Scala</a></li>
                            <li><a href="">Modules and Compilation</a></li>
                            <li><a href="">Packages</a></li>
                            <li><a href="">Functions</a></li>
                            <li><a href="">Properties And Fields</a></li>
                        </ul>-->
                        <div id="toc"></div>
                    </div>
                    <div class="col-4">
                            <p>In Kotlin, everything is an object in the sense that one can call member functions and properties on any variable. Some types are built-in, because their implementation is optimized, but for the used they look like ordinary classes. In this section we describe most of these types: numbers, characters, booleans and arrays.</p>

<h2 id="numbers">Numbers</h2>

<p>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions or numbers, and literals are slightly different in some cases.</p>

<p>Kotlin provides the following built-in types representing numbers (this is close to Java):</p>

<table>
  <tbody>
    <tr>
      <td>Type</td>
      <td>Bitwidth</td>
    </tr>
    <tr>
      <td>Double</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Float</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Long</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Int</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Short</td>
      <td>16</td>
    </tr>
    <tr>
      <td>Byte</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<p>Note that characters are not numbers in Kotlin.</p>

<h3 id="representation">Representation</h3>

<p>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. Int?) or generics are involved. In the latter cases numbers are boxed.</p>

<p>Note that boxing of numbers does not preserve identity:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">a</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">10000</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="n">identityEquals</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span>
<span class="k">val</span> <span class="n">boxedA</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="k">val</span> <span class="n">anotherBoxedA</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="n">print</span><span class="p">(</span><span class="n">boxedA</span> <span class="n">identityEquals</span> <span class="n">anotherBoxedA</span><span class="p">)</span> <span class="c1">// !!!Prints &#39;false&#39;!!!</span>
</code></pre></div>

<p>On the other hand, it preserves equality:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">a</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">10000</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span>
<span class="k">val</span> <span class="n">boxedA</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="k">val</span> <span class="n">anotherBoxedA</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="n">print</span><span class="p">(</span><span class="n">boxedA</span> <span class="p">==</span> <span class="n">anotherBoxedA</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span>
</code></pre></div>

<h3 id="explicit-conversions">Explicit Conversions</h3>

<p>Due to different representations, smaller types are not subtypes of bigger ones.
If they were, we would have troubles of the following sort</p>

<div class="highlight"><pre><code class="kotlin"><span class="c1">// Hypothetical code, does not actually compile:</span>
<span class="k">val</span> <span class="n">a</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// A boxed Int (java.lang.Integer)</span>
<span class="k">val</span> <span class="n">b</span> <span class="p">:</span> <span class="n">Long</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span> <span class="c1">// implicit conversion yields a boxed Long (java.lang.Long)</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// Surprise! This prints &quot;false&quot; as Long&#39;s equals() check for other part to be Long as well</span>
</code></pre></div>

<p>So not only identity, but even equality would have been lost silently all over the place.</p>

<p>As a consequence, smaller types are NOT implicitly converted to bigger types. This means that one cannot assign a value of type Byte to an Integer variable without an explicit conversion</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">b</span> <span class="p">:</span> <span class="n">Byte</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// OK, literals are checked statically</span>
<span class="k">val</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">b</span> <span class="c1">// ERROR</span>
</code></pre></div>

<p>We can use explicit conversions to widen numbers</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">i</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="c1">// OK: explicitly widened</span>
</code></pre></div>

<p>Every number type supports the following conversions:</p>

<ul>
  <li>toByte() : Byte</li>
  <li>toShort() : Short</li>
  <li>toInt() : Int</li>
  <li>toLong() : Long</li>
  <li>toFloat() : Float</li>
  <li>toDouble() : Double</li>
  <li>toChar() : Char</li>
</ul>

<p>Absence of implicit conversions is rarely noticeable because one can use literals almost freely cause the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">l</span> <span class="p">=</span> <span class="m">1.</span><span class="n">toLong</span><span class="p">()</span> <span class="p">+</span> <span class="m">3</span> <span class="c1">// Long + Int =&gt; Long</span>
</code></pre></div>

<h3 id="literals">Literals</h3>

<p>All the integer literals are written in the same way:</p>

<ul>
  <li>Decimals: 123, 123.5, 123.5e10</li>
  <li>Hexadecimals: 0x0F</li>
  <li>Binaries: 0b00001011</li>
</ul>

<p>NOTE: Octal literals are not supported.</p>

<p>There’re no “L”-tagged or otherwise tagged literals. In case of ambiguity, one should use explicit conversions to specify a type for a literal:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">list</span> <span class="p">=</span> <span class="n">list</span><span class="p">(</span><span class="m">1.</span><span class="n">toLong</span><span class="p">(),</span> <span class="m">100000000000</span><span class="p">,</span> <span class="m">2.</span><span class="n">toLong</span><span class="p">())</span>
</code></pre></div>

<h3 id="operations">Operations</h3>

<p>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See Operator overloading.</p>

<p>As of bitwise operations, there’re no special characters for them, but just named functions that can be called in infix form, for example:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="n">shl</span> <span class="m">2</span><span class="p">)</span> <span class="n">and</span> <span class="m">0</span><span class="n">x000FF000</span>
</code></pre></div>

<p>Here is the complete list of bitwise operations (available for Int and Long only):</p>

<ul>
  <li>shl(bits) – signed shift left (Java’s «)</li>
  <li>shr(bits) – signed shift right (Java’s »)</li>
  <li>ushr(bits) – unsigned shift right (Java’s »&gt;)</li>
  <li>and(bits) – bitwise and</li>
  <li>or(bits) – bitwise or</li>
  <li>xor(bits) – bitwise xor</li>
  <li>inv() – bitwise inversion</li>
</ul>

<h2 id="characters">Characters</h2>

<p>Characters are represented by the type Char. They are can not be treated directly as numbers</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">fun</span> <span class="nf">check</span><span class="p">(</span><span class="n">c</span> <span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ERROR: incompatible types</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Character literals go in single quotes: ‘1’, ‘\n’, ‘\uFF00’.
One can explicitly convert a character to an Int number</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">fun</span> <span class="nf">decimalDigitValue</span><span class="p">(</span><span class="n">c</span> <span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">!</span><span class="k">in</span> <span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="sc">&#39;9&#39;</span><span class="p">)</span>
    <span class="k">throw</span> <span class="nf">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Out of range&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="p">-</span> <span class="sc">&#39;0&#39;</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="c1">// Explicit conversions to numbers</span>
<span class="p">}</span>
</code></pre></div>

<p>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</p>

<h2 id="strings">Strings</h2>

<h2 id="booleans">Booleans</h2>

<p>The type Boolean represents booleans, and has two values: true and false.</p>

<p>Booleans are boxed if a nullable reference is needed.</p>

<p>Built-in operations on booleans include</p>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td> </td>
          <td>– lazy disjunction</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>&amp;&amp; – lazy conjunction</li>
</ul>

<h2 id="arrays">Arrays</h2>

<p>Arrays in Kotlin are represented by the Array class, that has get and set functions (that turn into [] by operator overloading conventions), and size, along with a few other useful member functions:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">class</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">val</span> <span class="n">size</span> <span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">init</span> <span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span> <span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">T</span>
  <span class="k">fun</span> <span class="nf">set</span><span class="p">(</span><span class="n">index</span> <span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">:</span> <span class="n">Unit</span>

  <span class="k">fun</span> <span class="nf">iterator</span><span class="p">()</span> <span class="p">:</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>

  <span class="k">val</span> <span class="n">indices</span> <span class="p">:</span> <span class="n">IntRange</span>
<span class="p">}</span>
</code></pre></div>

<p>To create an array one can call its constructor providing the array size and a function that knows how to initialize elements of the array</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">asc</span> <span class="p">=</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">5</span><span class="p">,</span> <span class="p">{</span><span class="n">i</span> <span class="p">-&gt;</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">})</span> <span class="c1">// Creates an array [0, 1, 4, 9, 16]</span>
</code></pre></div>

<p>Or, alternatively, one can use a library function array() and pass the item values to it, so that array(1, 2, 3) creates an array [1, 2, 3].</p>

<p>As we said above, the [] operation stands for calls to member functions get() and set(). When compiling to JVM byte codes, the compiler optimizes
access to arrays so that there’s no overhead introduced, and all operations work exactly like in Java</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">array</span> <span class="p">=</span> <span class="n">array</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
<span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">*</span> <span class="m">2</span> <span class="c1">// no actual calls to get() and set() generated</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="c1">// no iterator created</span>
  <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>

<p>Even when we navigate with an index, it does not introduce any overhead</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="c1">// no iterator created</span>
  <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+=</span> <span class="m">2</span>
</code></pre></div>

<p>Finally, in-checks have no overhead either</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// same as (i &gt;= 0 &amp;&amp; i &lt; array.size)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div>

<p>Note: arrays are invariant. For the best performance on the JVM use specialized array classes.</p>

<h2 id="strings-1">Strings</h2>

<p>Strings are represented by the type String. Strings are immutable. Elements of a string are characters can be accessed by the indexing operation: s[i]. A string can be iterated over with a for loop:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="string-literals">String Literals</h3>

<p>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">s</span> <span class="p">=</span> <span class="s">&quot;Hello, world!\n&quot;</span>
</code></pre></div>

<p>Escaping is done in the conventional way, with a backslash.</p>

<p>A raw string is delimited by a triple quote (“””), contains no escaping and can contain newlines and any other characters:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="s">&quot;&quot;&quot;</span>
</code></pre></div>

<h3 id="templates">Templates</h3>

<p>Strings may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign ($) and consists of either a simple name:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">i</span> <span class="p">=</span> <span class="m">10</span>
<span class="k">val</span> <span class="n">s</span> <span class="p">=</span> <span class="s">&quot;i = $i&quot;</span> <span class="c1">// evaluates to &quot;i = 10&quot;</span>
</code></pre></div>

<p>or an arbitrary expression in curly braces:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">s</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span>
<span class="k">val</span> <span class="n">str</span> <span class="p">=</span> <span class="s">&quot;$s.length is ${s.length}&quot;</span> <span class="c1">// evaluates to &quot;abc.length is 3&quot;</span>
</code></pre></div>


                    </div>
                </div>
            </div>

        </div>
        <div id="related">
            <h4>Related</h4>


            

        </div>

        <!--
Footer details such as copyright notice, etc.
-->

        <!--
Include all scripts required here
-->

<script type="text/javascript" src="/kotlin-web-site/scripts/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/kotlin-web-site/scripts/jquery.toc.min.js"></script>


        
    </section>
    </body>
</html>
