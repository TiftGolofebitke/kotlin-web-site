<!DOCTYPE html>
    <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">


<link rel="Shortcut Icon" href="/assets/images/favicon.ico" type="image/x-icon"/>
<link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png" />
<link rel="apple-touch-icon" sizes="72x72" href="/assets/images/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon" sizes="114x114" href="/assets/images/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon" sizes="144x144" href="/assets/images/apple-touch-icon-144x144.png" />
<link rel="stylesheet" href="/css/styles.css">
<link rel="stylesheet" href="/css/syntax.css">
<link rel="stylesheet" href="/css/keywords.css">


<title>Properties and Fields</title>

    </head>
    <body>
    <section>
        <div class="container">
            <div class="grid">
                <div class="row">
                    <div class="col-2">
                        <h1>Properties and Fields</h1>
                        <!--<ul class="navigation">
                            <li><a href="">Docs Home</a></li>
                            <li><a href="">Examples</a></li>
                            <li><a href="">Comparison to Java</a></li>
                            <li><a href="">Comparison to Scala</a></li>
                            <li><a href="">Modules and Compilation</a></li>
                            <li><a href="">Packages</a></li>
                            <li><a href="">Functions</a></li>
                            <li><a href="">Properties And Fields</a></li>
                        </ul>-->
                        <div id="toc"></div>
                    </div>
                    <div class="col-4">
                            <h2 id="declaring-properties">Declaring Properties</h2>

<p>Classes in Kotlin can have properties. These can be declared as mutable, using the <em class="keyword">var</em> keyword or immutable using the <em class="keyword">val</em> keyword.</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">public</span> <span class="k">class</span> <span class="nc">Address</span> <span class="p">{</span> <span class="c1">// parentheses denote a _primary constructor_</span>
  <span class="k">public</span> <span class="k">var</span> <span class="n">name</span> <span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="n">street</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="n">city</span> <span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="n">state</span> <span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="n">zip</span> <span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="getters-and-setters">Getters and Setters</h2>

<p>The full syntax for declaring a property is</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">var</span> <span class="p">&lt;</span><span class="n">propertyName</span><span class="p">&gt;</span> <span class="p">:</span> <span class="p">&lt;</span><span class="n">PropertyType</span><span class="p">&gt;</span> <span class="p">[=</span> <span class="p">&lt;</span><span class="n">property_initializer</span><span class="p">&gt;]</span>
  <span class="p">&lt;</span><span class="n">getter</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">setter</span><span class="p">&gt;</span>
</code></pre></div>

<p>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer or from the base class member being overridden .</p>

<p>Examples</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">var</span> <span class="p">*</span><span class="n">allByDefault</span><span class="p">*{:</span> <span class="p">.</span><span class="n">error</span> <span class="p">}</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="c1">// error: explicit initializer required, default getter and setter implied</span>
<span class="k">var</span> <span class="n">initialized</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// has type Int, default getter and setter</span>
<span class="k">var</span> <span class="n">setterVisibility</span> <span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span> <span class="c1">// Initializer required, not a nullable type</span>
  <span class="k">private</span> <span class="k">set</span> <span class="c1">// the setter is private and has the default implementation</span>
</code></pre></div>

<p>Note that types are not inferred for properties exposed as parts of the public API, i.e. public and protected, because changing the initializer may cause an unintentional change in the public API then. For example</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">public</span> <span class="k">val</span> <span class="p">*</span><span class="n">example</span><span class="p">*{:</span> <span class="p">.</span><span class="n">error</span> <span class="p">}</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// A public property must have a type specified explicitly</span>
</code></pre></div>

<p>The full syntax of an immutable property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">simple</span> <span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="c1">// has type Int, default getter, must be initialized in constructor</span>
<span class="k">val</span> <span class="n">inferredType</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// has type Int and a default getter</span>
</code></pre></div>

<p>We can write custom accessors, very much like ordinary functions, right inside a property declaration. Here’s an example of a custom getter:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">isEmpty</span> <span class="p">:</span> <span class="n">Boolean</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">size</span> <span class="p">==</span> <span class="m">0</span>
</code></pre></div>

<p>Since this property is purely derived from others, the compiler will not generate a backing field for it.</p>

<p>A custom setter looks like this:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">var</span> <span class="n">stringRepresentation</span> <span class="p">:</span> <span class="n">String</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
  <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setDataFromString</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// parses the string and assigns values to other properties</span>
  <span class="p">}</span>
</code></pre></div>

<h3 id="backing-fields">Backing Fields</h3>

<p>Classes in Kotlin cannot have fields. However, sometimes it is necessary to have a backing field when using custom accessors. For these purposes, Kotlin provides
an automatic backing field which can be accessed using the <em>$</em> symbol followed by the property name.</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">var</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">0</span> <span class="c1">// the initializer value is written directly to the backing field</span>
  <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)</span>
      <span class="err">$</span><span class="n">counter</span> <span class="p">=</span> <span class="n">value</span>
  <span class="p">}</span>
</code></pre></div>

<p>The $counter field can be accessed only from inside the class where the counter property is defined.</p>

<p>The compiler looks at the accessors’ bodies, and if they use the backing field (or the accessor implementation is left by default), a backing field is generated, otherwise it is not.</p>

<p>For example, in the following case there will be no backing field:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">val</span> <span class="n">isEmpty</span> <span class="p">:</span> <span class="n">Boolean</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">size</span> <span class="p">&gt;</span> <span class="m">0</span>
</code></pre></div>

<h3 id="backing-properties">Backing Properties</h3>

<p>If you want to do something that does not fit into this “implicit backing field” scheme, you can always fall back to having a “backing property”:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">private</span> <span class="k">var</span> <span class="n">_table</span> <span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
<span class="k">public</span> <span class="k">val</span> <span class="n">table</span> <span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_table</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
      <span class="n">_table</span> <span class="p">=</span> <span class="n">HashMap</span><span class="p">()</span> <span class="c1">// Type parameters are inferred</span>
    <span class="k">return</span> <span class="n">_table</span> <span class="p">?:</span> <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;Set to null by another thread&quot;</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div>

<p>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</p>

<h2 id="overriding-properties">Overriding Properties</h2>

<p>See <a href="/docs/classes.html#overriding-properties">Overriding Properties</a></p>

<h2 id="using-properties">Using Properties</h2>

<p>To use a property, one simply refers to it by name, as if it were a field in Java:</p>

<div class="highlight"><pre><code class="kotlin"><span class="k">fun</span> <span class="nf">copyAddress</span><span class="p">(</span><span class="n">address</span> <span class="p">:</span> <span class="n">Address</span><span class="p">)</span> <span class="p">:</span> <span class="n">Address</span> <span class="p">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="p">=</span> <span class="n">Address</span><span class="p">()</span> <span class="c1">// there&#39;s no &#39;new&#39; keyword in Kotlin</span>
  <span class="n">result</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">name</span> <span class="c1">// accessors are called</span>
  <span class="n">result</span><span class="p">.</span><span class="n">street</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">street</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div>


                    </div>
                </div>
            </div>

        </div>
        <div id="related">
            <h4>Related</h4>


            

        </div>

        <!--
Footer details such as copyright notice, etc.
-->

        <!--
Include all scripts required here
-->

<script type="text/javascript" src="/scripts/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/scripts/jquery.toc.min.js"></script>


        
    </section>
    </body>
</html>
